!SFX_LIC Copyright 1994-2014 CNRS, Meteo-France and Universite Paul Sabatier
!SFX_LIC This is part of the SURFEX software governed by the CeCILL-C licence
!SFX_LIC version 1. See LICENSE, CeCILL-C_V1-en.txt and CeCILL-C_V1-fr.txt  
!SFX_LIC for details. version 1.
SUBROUTINE INIT_INDEX_MPI (YSC, &
                           HPROGRAM,HALG,PIO_FRAC,OSHADOWS)
!
! 04-2014 : Modifs Matthieu Lafaysse for shadows :
!        * OSHADOWS logical to pass to get_sizes_parallel
!        * disactivate the treatments relative to PIO_FRAC in case of shadows
!        * MPI_BCAST of NIX and NIY
!
USE MODD_SURFEX_n, ONLY : SURFEX_t
!
USE MODD_SURFEX_MPI, ONLY : NRANK, NPIO, NPROC, NCOMM, NINDEX, NSIZE_TASK, NSIZE, WLOG_MPI
USE MODD_SURFEX_OMP, ONLY : NINDX2SFX, NWORK, NWORK2, XWORK, XWORK2, XWORK3, &
                            NWORK_FULL, NWORK2_FULL, XWORK_FULL, XWORK2_FULL
!
USE MODD_MASK, ONLY : NMASK_FULL
!
USE MODD_SLOPE_EFFECT, ONLY : NIX,NIY
!
USE MODE_READ_SURF_COV, ONLY : READ_SURF_COV
!
USE MODI_GET_LUOUT
USE MODI_SET_SURFEX_FILEIN
USE MODI_INIT_IO_SURF_n
USE MODI_READ_SURF
USE MODI_READ_GRIDTYPE
USE MODI_END_IO_SURF_n
USE MODI_ABOR1_SFX
USE MODI_GET_SIZES_PARALLEL
USE MODI_GET_ADJACENT_MESHES
USE MODI_GET_SIZE_FULL_n
USE MODI_INI_DATA_COVER
USE MODI_READ_ARRANGE_COVER
USE MODI_READ_COVER_GARDEN
!
USE YOMHOOK   ,ONLY : LHOOK,   DR_HOOK
USE PARKIND1  ,ONLY : JPRB
!
IMPLICIT NONE
!
#ifdef SFX_MPI
INCLUDE "mpif.h"
#endif
!
!
TYPE(SURFEX_t), INTENT(INOUT) :: YSC
!
 CHARACTER(LEN=6), INTENT(IN) :: HPROGRAM
 CHARACTER(LEN=4), INTENT(IN) :: HALG
REAL, INTENT(IN) :: PIO_FRAC
LOGICAL, INTENT(IN) :: OSHADOWS
!
INTEGER, DIMENSION(:), ALLOCATABLE :: ILEFT   ! index of left   grid mesh 
INTEGER, DIMENSION(:), ALLOCATABLE :: IRIGHT  ! index of right  grid mesh 
INTEGER, DIMENSION(:), ALLOCATABLE :: ITOP    ! index of top    grid mesh 
INTEGER, DIMENSION(:), ALLOCATABLE :: IBOTTOM ! index of bottom grid mesh
!
INTEGER, DIMENSION(0:NPROC-1) :: INBPTS
INTEGER :: IRESTE, INRESTE, IRANK, IPROC
INTEGER :: JJ, CPT, ILUOUT, INBMIN, IP0
INTEGER :: IRESP, INFOMPI
REAL(KIND=JPRB) :: ZHOOK_HANDLE
!
IF (LHOOK) CALL DR_HOOK('INIT_INDEX_MPI',0,ZHOOK_HANDLE)
!
IF ( NRANK==NPIO ) THEN
  !
  CALL GET_LUOUT(HPROGRAM,ILUOUT)
  !
  !*    1. Parameters of the grid
  !
  CALL SET_SURFEX_FILEIN(HPROGRAM,'PGD ')
 CALL INIT_IO_SURF_n(YSC%DTCO, YSC%DGU, YSC%U, &
                        HPROGRAM,'FULL  ','SURF  ','READ ')
  !
  CALL READ_SURF(&
                 HPROGRAM,'DIM_FULL  ',YSC%U%NDIM_FULL,IRESP,HDIR='A')
  NINDX2SFX = YSC%U%NDIM_FULL
  !
  CALL READ_ARRANGE_COVER(&
                          HPROGRAM,YSC%U%LWATER_TO_NATURE,YSC%U%LTOWN_TO_ROCK,'A')
  CALL READ_COVER_GARDEN(&
                         HPROGRAM,YSC%U%LGARDEN,'A')
  !
  CALL END_IO_SURF_n(HPROGRAM)
  DEALLOCATE(NMASK_FULL)
  !
  CALL SET_SURFEX_FILEIN(HPROGRAM,'PGD ') ! change input file name to pgd name
 CALL INIT_IO_SURF_n(YSC%DTCO, YSC%DGU, YSC%U, &
                        HPROGRAM,'FULL  ','SURF  ','READ ')
  !
  CALL READ_SURF(&
                 HPROGRAM,'GRID_TYPE',YSC%UG%CGRID,IRESP,HDIR='A')
  !
  CALL READ_GRIDTYPE(&
                     HPROGRAM,YSC%UG%CGRID,YSC%UG%NGRID_PAR,YSC%U%NDIM_FULL,.FALSE.,HDIR='A')
  !
  ALLOCATE(YSC%UG%XGRID_FULL_PAR(YSC%UG%NGRID_PAR))
  !
  CALL READ_GRIDTYPE(&
                     HPROGRAM,YSC%UG%CGRID,YSC%UG%NGRID_PAR,YSC%U%NDIM_FULL,.TRUE.,&
                     YSC%UG%XGRID_FULL_PAR,IRESP,HDIR='A')
  !
  !
  CALL END_IO_SURF_n(HPROGRAM)
  !
  ALLOCATE(NWORK_FULL(YSC%U%NDIM_FULL))
  ALLOCATE(XWORK_FULL(YSC%U%NDIM_FULL))
  ALLOCATE(NWORK2_FULL(YSC%U%NDIM_FULL,10))
  ALLOCATE(XWORK2_FULL(YSC%U%NDIM_FULL,10))
  !
ELSE
  ALLOCATE(NWORK_FULL(0))
  ALLOCATE(XWORK_FULL(0))
  ALLOCATE(NWORK2_FULL(0,0))
  ALLOCATE(XWORK2_FULL(0,0))
ENDIF
!

IF (NPROC>1) THEN
#ifdef SFX_MPI
  CALL MPI_BCAST(YSC%U%NDIM_FULL,KIND(YSC%U%NDIM_FULL)/4,MPI_INTEGER,NPIO,NCOMM,INFOMPI)
#endif
 NINDX2SFX = YSC%U%NDIM_FULL
ENDIF
!
!*     3. Points by task
!
IF (.NOT.ALLOCATED(NINDEX)) ALLOCATE(NINDEX(YSC%U%NDIM_FULL))
NINDEX(:) = -1
!
IF (NRANK==NPIO) THEN
  !
  IF (HALG=='LIN ') THEN
    !
    CALL SET_NB_POINTS_LIN(NPROC,NPROC-1,YSC%U%NDIM_FULL,NINDEX,OSHADOWS)
    !
  ELSEIF (HALG=='ADJ ' .OR. HALG=='TILA' .OR. HALG=='TILL') THEN
    !
    IF (HALG=='ADJ ' .OR. HALG=='TILA') THEN
      ALLOCATE(ILEFT  (YSC%U%NDIM_FULL))
      ALLOCATE(IRIGHT (YSC%U%NDIM_FULL))
      ALLOCATE(IBOTTOM(YSC%U%NDIM_FULL))
      ALLOCATE(ITOP   (YSC%U%NDIM_FULL))
      CALL GET_ADJACENT_MESHES(YSC%UG%CGRID,YSC%UG%NGRID_PAR,YSC%U%NDIM_FULL,&
                                YSC%UG%XGRID_FULL_PAR,ILEFT,IRIGHT,ITOP,IBOTTOM)
    ELSE
      ALLOCATE(ILEFT  (0))
      ALLOCATE(IRIGHT (0))
      ALLOCATE(IBOTTOM(0))
      ALLOCATE(ITOP   (0))
    ENDIF
    !
    IF (HALG=='ADJ ') THEN
      CALL SET_NB_POINTS_ADJ(NPROC,YSC%U%NDIM_FULL,YSC%U%NDIM_FULL,ILEFT,IRIGHT,ITOP,IBOTTOM,NINDEX,OSHADOWS)
    ELSEIF (HALG=='TILA' .OR. HALG=='TILL') THEN
      CALL INI_DATA_COVER(YSC%DTCO, YSC%U)
      CALL SET_NB_POINTS_TIL(HPROGRAM,HALG,NPROC,YSC%U%NDIM_FULL,ILEFT,IRIGHT,ITOP,IBOTTOM,NINDEX,OSHADOWS)
    ENDIF
    !
    DEALLOCATE(ILEFT  )
    DEALLOCATE(IRIGHT )
    DEALLOCATE(ITOP   )
    DEALLOCATE(IBOTTOM)
    !
  ELSE
    !
    CALL ABOR1_SFX("INIT_INDEX_MPI: ALG="//HALG//" not defined for the moment")
    !
  ENDIF
  !
  IF (NPROC>1) THEN
    !
    INBPTS(:) = 0
    DO JJ=1,SIZE(NINDEX)
      INBPTS(NINDEX(JJ)) = INBPTS(NINDEX(JJ)) + 1
    ENDDO
    !   
    INBMIN = MINVAL(INBPTS)
    IP0 = MAXVAL(MINLOC(INBPTS)) - 1
    !   
    IF (.NOT. OSHADOWS) THEN
    ! Matthieu Lafaysse :
    ! With shadows we don't want the repartition of points to be modified by the following instructions
    
      DO WHILE( INBPTS(NPIO) > NINT(PIO_FRAC*INBMIN) )
        !
        DO JJ=1,SIZE(NINDEX)
          IF (NINDEX(JJ)==NPIO) THEN
            NINDEX(JJ) = IP0
            INBPTS(NPIO) = INBPTS(NPIO) - 1
            INBPTS(IP0) = INBPTS(IP0) + 1
            EXIT
          ENDIF
        ENDDO
      !
        INBMIN = MAXVAL(INBPTS)
        IP0 = 0
        DO JJ=0,NPROC-1
          IF (JJ/=NPIO .AND. INBPTS(JJ)<INBMIN) THEN
            INBMIN = INBPTS(JJ)
            IP0 = JJ
          ENDIF
        ENDDO
      !
      END DO
    
    END IF
    !
  ENDIF
  !
ENDIF
!

IF (NPROC>1) THEN
#ifdef SFX_MPI
  CALL MPI_BCAST(NINDEX,SIZE(NINDEX)*KIND(NINDEX)/4,MPI_INTEGER,NPIO,NCOMM,INFOMPI) 
  IF (OSHADOWS) THEN
  ! Matthieu Lafaysse :
  ! Each thread need to know NIX and NIY
    CALL MPI_BCAST(NIX,KIND(NIX)/4,MPI_INTEGER,NPIO,NCOMM,INFOMPI)
    CALL MPI_BCAST(NIY,KIND(NIY)/4,MPI_INTEGER,NPIO,NCOMM,INFOMPI)
  ENDIF
#endif
ENDIF
!
ALLOCATE(NSIZE_TASK(0:NPROC-1))
NSIZE_TASK(:) = 0
!
 CALL GET_SIZE_FULL_n(YSC%U, &
                      HPROGRAM,YSC%U%NDIM_FULL,NSIZE_TASK(NRANK))
NINDX2SFX = NSIZE_TASK(NRANK)
!
NSIZE = 0
IF (NPROC>1) THEN
  DO JJ=0,NPROC-1
#ifdef SFX_MPI
    CALL MPI_BCAST(NSIZE_TASK(JJ),KIND(NSIZE_TASK)/4,MPI_INTEGER,JJ,NCOMM,INFOMPI)
#endif
    IF ( NSIZE_TASK(JJ)>NSIZE ) NSIZE = NSIZE_TASK(JJ)
    CALL WLOG_MPI('SIZE_TASK ',KLOG=JJ,KLOG2=NSIZE_TASK(JJ))
  ENDDO
ELSE
  NSIZE = NSIZE_TASK(0)
ENDIF
!
YSC%UG%XGRID_FULL_PAR=>NULL()
!
ALLOCATE(NWORK(NSIZE))
ALLOCATE(XWORK(NSIZE))
ALLOCATE(NWORK2(NSIZE,10))
ALLOCATE(XWORK2(NSIZE,10))
ALLOCATE(XWORK3(NSIZE,10,10))
!
IF (LHOOK) CALL DR_HOOK('INIT_INDEX_MPI',1,ZHOOK_HANDLE)
!
 CONTAINS
!
!***************************************************************
!
SUBROUTINE SET_NB_POINTS_LIN(KPROC,KPROCMIN,KSIZE,KINDEX,OSHADOWS)
!
IMPLICIT NONE
!
INTEGER, INTENT(IN) :: KPROC
INTEGER, INTENT(IN) :: KPROCMIN
INTEGER, INTENT(IN) :: KSIZE
INTEGER, DIMENSION(:), INTENT(INOUT) :: KINDEX
LOGICAL, INTENT(IN) :: OSHADOWS
!
INTEGER, DIMENSION(0:KPROC-1) :: ISIZE_TASK
INTEGER :: JI, JJ, CPT, IPROC1
REAL(KIND=JPRB) :: ZHOOK_HANDLE
!
IF (LHOOK) CALL DR_HOOK('INIT_INDEX_MPI:SET_NB_POINTS_LIN',0,ZHOOK_HANDLE)
!
 CALL GET_SIZES_PARALLEL(YSC%DTCO, YSC%DGU, YSC%UG, YSC%U, &
                         KPROC,KSIZE,KPROCMIN,ISIZE_TASK,OSHADOWS)
!
IPROC1 = KPROCMIN
!
 CPT   = 0
!
DO JJ=1,SIZE(KINDEX) ! boucle sur les points du domaine
  !
  IF (KINDEX(JJ)==-1) THEN ! si le point doit être affecté à cette itération
    CPT = CPT + 1 ! on augmente le nombre de points affectés de 1
    DO WHILE( CPT>ISIZE_TASK(IPROC1) ) ! si on est hors les bornes permises par le proc en cours
      IF ( IPROC1.GE.KPROCMIN ) THEN ! d'abord, on va de IPROCMIN à IPROC-1
        IPROC1 = IPROC1+1
        IF ( IPROC1==KPROC ) IPROC1 = KPROCMIN-1 ! une fois qu'on est à IPROC-1,
      ELSE                                       ! on redescend sous IPROC1
        IPROC1 = IPROC1-1
      ENDIF
      CPT = 1
    ENDDO
    KINDEX(JJ) = IPROC1
  ENDIF
  !
ENDDO
!

IF (LHOOK) CALL DR_HOOK('INIT_INDEX_MPI:SET_NB_POINTS_LIN',1,ZHOOK_HANDLE)
!
END SUBROUTINE SET_NB_POINTS_LIN
!
!**************************************************************************
!
SUBROUTINE SET_NB_POINTS_ADJ(KPROC,KSIZE,KSIZE_FULL,KLEFT,KRIGHT,KTOP,KBOTTOM,KINDEX,OSHADOWS)
!
IMPLICIT NONE
!
INTEGER, INTENT(IN) :: KPROC
INTEGER, INTENT(IN) :: KSIZE
INTEGER, INTENT(IN) :: KSIZE_FULL
INTEGER, DIMENSION(KSIZE_FULL), INTENT(IN) :: KLEFT
INTEGER, DIMENSION(KSIZE_FULL), INTENT(IN) :: KRIGHT
INTEGER, DIMENSION(KSIZE_FULL), INTENT(IN) :: KTOP 
INTEGER, DIMENSION(KSIZE_FULL), INTENT(IN) :: KBOTTOM
INTEGER, DIMENSION(KSIZE_FULL), INTENT(INOUT) :: KINDEX
LOGICAL, INTENT(IN) :: OSHADOWS
!
INTEGER, DIMENSION(KSIZE_FULL) :: IPOINT
INTEGER, DIMENSION(0:KPROC-1) :: ISIZE_TASK
INTEGER, DIMENSION(4) :: INEAR
INTEGER :: CPT_TOT, CPT_LOC, CPT_INTER, JI, JJ, JK
!
REAL(KIND=JPRB) :: ZHOOK_HANDLE
!
IF (LHOOK) CALL DR_HOOK('INIT_INDEX_MPI:SET_NB_POINTS_ADJ',0,ZHOOK_HANDLE)
!
 CALL GET_SIZES_PARALLEL(YSC%DTCO, YSC%DGU, YSC%UG, YSC%U, &
                         KPROC,KSIZE,NPIO,ISIZE_TASK,OSHADOWS)
!
DO JI=1,KPROC-1
  !
  CPT_INTER = 0
  CPT_LOC   = 0
  CPT_TOT   = 0
  !
  DO WHILE ( CPT_TOT < ISIZE_TASK(JI) )
    !
    IF (CPT_LOC < 1 ) THEN ! if no free point has been found in neighbours
      !
      DO JJ=1,KSIZE_FULL
        IF ( KINDEX(JJ)==-1 ) THEN
          CPT_TOT = CPT_TOT + 1
          CPT_LOC = 1
          IPOINT(1) = JJ
          KINDEX(JJ) = JI
          EXIT
        ENDIF
      ENDDO
      !
    ENDIF
    !
    IPOINT(1:CPT_LOC-CPT_INTER) = IPOINT(CPT_INTER+1:CPT_LOC)
    CPT_LOC   = CPT_LOC - CPT_INTER
    CPT_INTER = CPT_LOC
    !
    B1 : DO JJ=1,CPT_INTER
      !
      INEAR(1) = KBOTTOM(IPOINT(JJ))
      INEAR(2) = KLEFT  (IPOINT(JJ))
      INEAR(3) = KRIGHT (IPOINT(JJ)) 
      INEAR(4) = KTOP   (IPOINT(JJ))    
      !
      DO JK=1,4
        !
        IF ( INEAR(JK).NE.0 ) THEN
          IF( KINDEX(INEAR(JK)).EQ.-1 ) THEN
            CPT_TOT = CPT_TOT + 1
            CPT_LOC = CPT_LOC + 1
            IF (CPT_TOT.GT.ISIZE_TASK(JI)) EXIT B1
            KINDEX(INEAR(JK)) = JI
            IPOINT(CPT_LOC) = INEAR(JK)
          ENDIF
        ENDIF
        !
      ENDDO
      !
    ENDDO B1
    !
  ENDDO
  !
ENDDO
!
WHERE (KINDEX(:)==-1) KINDEX(:) = 0
!
IF (LHOOK) CALL DR_HOOK('INIT_INDEX_MPI:SET_NB_POINTS_ADJ',1,ZHOOK_HANDLE)
!
END SUBROUTINE SET_NB_POINTS_ADJ
!
!*****************************************************************
!
SUBROUTINE SET_NB_POINTS_TIL(HPROGRAM,HALG,KPROC,KSIZE_FULL,KLEFT,KRIGHT,KTOP,KBOTTOM,KINDEX,OSHADOWS)
!
! modif 
! 05/14 B. Decharme Partion done according to patch and not vegtype (vegtype can be > to patch grid)
!
USE MODD_DATA_COVER_PAR, ONLY : NVEGTYPE, JPCOVER
USE MODD_SURF_PAR,       ONLY : XUNDEF
!
USE MODI_AV_PGD
USE MODI_SURF_PATCH
!
IMPLICIT NONE
!
 CHARACTER(LEN=6), INTENT(IN) :: HPROGRAM
 CHARACTER(LEN=4), INTENT(IN) :: HALG
INTEGER, INTENT(IN) :: KPROC
INTEGER, INTENT(IN) :: KSIZE_FULL
INTEGER, DIMENSION(KSIZE_FULL), INTENT(IN) :: KLEFT
INTEGER, DIMENSION(KSIZE_FULL), INTENT(IN) :: KRIGHT
INTEGER, DIMENSION(KSIZE_FULL), INTENT(IN) :: KTOP 
INTEGER, DIMENSION(KSIZE_FULL), INTENT(IN) :: KBOTTOM
INTEGER, DIMENSION(KSIZE_FULL), INTENT(INOUT) :: KINDEX
LOGICAL, INTENT(IN) :: OSHADOWS
!
REAL, DIMENSION(KSIZE_FULL) :: ZSEA
REAL, DIMENSION(KSIZE_FULL) :: ZWATER
REAL, DIMENSION(KSIZE_FULL) :: ZNATURE
REAL, DIMENSION(KSIZE_FULL) :: ZTOWN
REAL, DIMENSION(KSIZE_FULL, JPCOVER)  :: ZCOVER
REAL, DIMENSION(KSIZE_FULL, NVEGTYPE) :: ZVEGTYPE
INTEGER, DIMENSION(KSIZE_FULL,2) :: ITYPE 
INTEGER,DIMENSION(4,17) :: ITYPE0
INTEGER, DIMENSION(KSIZE_FULL) :: IINDEX
INTEGER, DIMENSION(0:KPROC-1) :: ISIZE_TASK
INTEGER, DIMENSION(0:KPROC-1) :: INBPTS
INTEGER, DIMENSION(1) :: IPROCMIN
INTEGER :: IFULL, IRESP, JJ, JI, JK, JVEGTYPE, CPT, IN1, IN2
 CHARACTER(LEN=6) :: YNATURE
LOGICAL, DIMENSION(JPCOVER) :: GCOVER
LOGICAL :: GDATA_VEGTYPE
!
 CHARACTER(LEN=12) :: YRECFM         ! Name of the article to be read
INTEGER           :: IVERSION, IPATCH
REAL, DIMENSION(:,:), ALLOCATABLE :: ZPATCH
!
REAL(KIND=JPRB) :: ZHOOK_HANDLE
!
IF (LHOOK) CALL DR_HOOK('INIT_INDEX_MPI:SET_NB_POINTS_TIL',0,ZHOOK_HANDLE)
!
GDATA_VEGTYPE = .FALSE.
!
! Full read
!
 CALL INIT_IO_SURF_n(YSC%DTCO, YSC%DGU, YSC%U, &
                        HPROGRAM,'FULL  ','SURF  ','READ ')
!
 CALL READ_SURF(&
                 HPROGRAM,'FRAC_SEA   ',ZSEA,   IRESP, HDIR='A')
 CALL READ_SURF(&
                 HPROGRAM,'FRAC_NATURE',ZNATURE,IRESP, HDIR='A')
 CALL READ_SURF(&
                 HPROGRAM,'FRAC_WATER ',ZWATER, IRESP, HDIR='A')
 CALL READ_SURF(&
                 HPROGRAM,'FRAC_TOWN  ',ZTOWN,  IRESP, HDIR='A')
 CALL READ_SURF(&
                 HPROGRAM,'NATURE     ',YNATURE,IRESP, HDIR='A')
 CALL READ_SURF(&
                 HPROGRAM,'VERSION    ',IVERSION,IRESP,HDIR='A')
!
 CALL END_IO_SURF_n(HPROGRAM)
!
! Nature read
!
IF (YNATURE/='NONE' .AND. SUM(ZNATURE)>0.) THEN
!
  !CALL SET_SURFEX_FILEIN(HPROGRAM,'PGD')
 CALL INIT_IO_SURF_n(YSC%DTCO, YSC%DGU, YSC%U, &
                        HPROGRAM,'NATURE','SURF  ','READ ')
!
  YRECFM='PATCH_NUMBER'
  CALL READ_SURF(&
                 HPROGRAM,YRECFM,IPATCH,IRESP,HDIR='A')
  ALLOCATE(ZPATCH(KSIZE_FULL,IPATCH))
  ZPATCH(:,:)=0.0
!  
  IF (IVERSION<8) CALL READ_SURF(&
                 HPROGRAM,'L_VEGTYPE',GDATA_VEGTYPE,IRESP,HDIR='A')
!
ELSE
!
  ALLOCATE(ZPATCH(KSIZE_FULL,1))
  ZPATCH(:,:)=0.0
!
ENDIF
!
IF (IVERSION >= 8 .AND. YNATURE/='NONE' .AND. SUM(ZNATURE)>0.) THEN
!
   CALL END_IO_SURF_n(HPROGRAM)
!
   CALL SET_SURFEX_FILEIN(HPROGRAM,'PREP')
 CALL INIT_IO_SURF_n(YSC%DTCO, YSC%DGU, YSC%U, &
                        HPROGRAM,'NATURE','SURF  ','READ ')
   YRECFM = 'PATCH'
   CALL READ_SURF(&
                 HPROGRAM,YRECFM,ZPATCH(:,:),IRESP,HDIR='A')
   WHERE(ZPATCH(:,:)==XUNDEF)ZPATCH=0.0
   CALL END_IO_SURF_n(HPROGRAM)
!
ELSE
!
  IF (GDATA_VEGTYPE) THEN
    CALL READ_SURF(&
                 HPROGRAM,'D_VEGTYPE',ZVEGTYPE(:,:),IRESP,HDIR='A')
    CALL END_IO_SURF_n(HPROGRAM)
  ELSE
    CALL END_IO_SURF_n(HPROGRAM)
 CALL INIT_IO_SURF_n(YSC%DTCO, YSC%DGU, YSC%U, &
                        HPROGRAM,'FULL  ','SURF  ','READ ')    
    CALL READ_SURF(&
                 HPROGRAM,'COVER_LIST',GCOVER(:),IRESP,HDIR='A')
    CALL READ_SURF_COV(&
                       HPROGRAM,'COVER',ZCOVER(:,:),GCOVER,IRESP,HDIR='A')
    DO JVEGTYPE=1,NVEGTYPE
      CALL AV_PGD(YSC%DTCO, &
                   ZVEGTYPE(:,JVEGTYPE),ZCOVER,YSC%DTCO%XDATA_VEGTYPE(:,JVEGTYPE),'NAT','ARI',GCOVER)
    END DO
  ENDIF
!
  CALL END_IO_SURF_n(HPROGRAM)
!
  CALL SURF_PATCH(IPATCH,ZVEGTYPE,ZPATCH)
!
ENDIF
!
! Algo
!
ITYPE(:,:) = 0
!
DO JJ=1,KSIZE_FULL
  !
  IF (ZSEA(JJ)/=0. .AND. ZNATURE(JJ)/=0. .AND. ZWATER(JJ)/=0. .AND. ZTOWN(JJ)/=0.) THEN ! 1 2 3 4
    ITYPE(JJ,1) = 1 
  ELSEIF (ZSEA(JJ)/=0. .AND. ZNATURE(JJ)/=0. .AND. ZWATER(JJ)/=0.) THEN ! 1 2 3
    ITYPE(JJ,1) = 2
  ELSEIF (ZSEA(JJ)/=0. .AND. ZNATURE(JJ)/=0. .AND. ZTOWN(JJ)/=0.) THEN ! 1 2 4
    ITYPE(JJ,1) = 3
  ELSEIF (ZSEA(JJ)/=0. .AND. ZWATER(JJ)/=0. .AND. ZTOWN(JJ)/=0.) THEN ! 1 3 4 
    ITYPE(JJ,1) = 4
  ELSEIF (ZNATURE(JJ)/=0. .AND. ZWATER(JJ)/=0. .AND. ZTOWN(JJ)/=0.) THEN ! 2 3 4
    ITYPE(JJ,1) = 5
  ELSEIF (ZSEA(JJ)/=0.) THEN 
    IF (ZNATURE(JJ)/=0.) THEN ! 1 2
      ITYPE(JJ,1) = 6
    ELSEIF (ZWATER(JJ)/=0.) THEN ! 1 3
      ITYPE(JJ,1) = 7
    ELSEIF (ZTOWN(JJ)/=0.) THEN ! 1 4
      ITYPE(JJ,1) = 8
    ELSE ! 1
      ITYPE(JJ,1) = 12
    ENDIF
  ELSEIF (ZNATURE(JJ)/=0.) THEN
    IF (ZWATER(JJ)/=0.) THEN ! 2 3
      ITYPE(JJ,1) = 9
    ELSEIF (ZTOWN(JJ)/=0.) THEN ! 2 4
      ITYPE(JJ,1) = 10
    ELSE ! 2
      ITYPE(JJ,1) = 13
    ENDIF
  ELSEIF (ZWATER(JJ)/=0.) THEN
    IF (ZTOWN(JJ)/=0.) THEN ! 3 4
      ITYPE(JJ,1) = 11
    ELSE ! 3
      ITYPE(JJ,1) = 14
    ENDIF
  ELSE ! 4
    ITYPE(JJ,1) = 15
  ENDIF
  !
ENDDO
!
!we give numbers to the 40 types of vegtypes
 CPT = 0
DO JI = 1,SIZE(ITYPE0,1)
  DO JJ = 1,SIZE(ITYPE0,2)
    CPT = CPT + 1
    ITYPE0(JI,JJ) = CPT
  ENDDO
ENDDO
!
DO JJ=1,KSIZE_FULL
  IN1 = 0
  IN2 = 0
  DO JI=1,MIN(3,IPATCH)
    IF (ZPATCH(JJ,JI)/=0.) IN1 = IN1 +1
  ENDDO
  DO JI=4,IPATCH
    IF (ZPATCH(JJ,JI)/=0.) IN2 = IN2 +1
  ENDDO
  ITYPE(JJ,2) = ITYPE0(IN1+1,IN2+1)
ENDDO
!
KINDEX(:) = -1
!
DO JI = 1,15
  !
  DO JJ = 1,68
    !
    !count of the points in the couple of types
    IINDEX(:) = -2
    DO JK=1,KSIZE_FULL
      IF (ITYPE(JK,1)==JI .AND. ITYPE(JK,2)==JJ) IINDEX(JK) = -1
    ENDDO
    !
    IFULL = COUNT(IINDEX(:)==-1)
    !
    IF (IFULL.NE.0) THEN
      !
      INBPTS(:) = 0
      DO JK=1,SIZE(KINDEX)
        IF (KINDEX(JK)>-1) INBPTS(KINDEX(JK)) = INBPTS(KINDEX(JK)) + 1
      ENDDO
      IF (KPROC>1) THEN
        IPROCMIN = MINLOC(INBPTS(0:KPROC-1))-1
      ELSE
        IPROCMIN(:) = 0
      ENDIF
      !
      IF (HALG=='TILL') THEN
        CALL SET_NB_POINTS_LIN(KPROC,IPROCMIN(1),IFULL,IINDEX(:),OSHADOWS)
      ELSEIF (HALG=='TILA') THEN
        CALL SET_NB_POINTS_ADJ(KPROC,IFULL,KSIZE_FULL,KLEFT,KRIGHT,KTOP,KBOTTOM,IINDEX(:),OSHADOWS)
      ENDIF
      !
      DO JK=1,KSIZE_FULL
        IF ( IINDEX(JK)> -1 ) KINDEX(JK) = IINDEX(JK)
      ENDDO
      !
   
    ENDIF
    !
  ENDDO
  !
ENDDO
!
DEALLOCATE(ZPATCH)
!
IF (LHOOK) CALL DR_HOOK('INIT_INDEX_MPI:SET_NB_POINTS_TIL',1,ZHOOK_HANDLE)
!
END SUBROUTINE SET_NB_POINTS_TIL
!
!
!
END SUBROUTINE INIT_INDEX_MPI
